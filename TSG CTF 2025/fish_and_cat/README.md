# fish_and_cat
この問題は解けてないですが，AIを使わずに答えに肉薄した問題なので，考えた事を書こうと思います．

## ルール解説



この問題はfishという難読化プログラムを実行して，思い通りに動かせたらフラグをゲットできるというシンプルな問題です．

> fishについては分かりやすい記事がたくさんあるので調べてみてください！
> esolang wiki: [fish](https://esolangs.org/wiki/Fish)

各ASCII文字に次のような役割が与えられています．

| 記号 | 10進数 | 動作 |
| :--- | :--- | :--- |
| `!` | 33 | ポインタを1つスキップする（moveを2回行う） |
| `"` | 34 | （TODO / 未実装） |
| `#` | 35 | 反転：現在の移動速度（方向）を反転させる |
| `$` | 36 | 入れ替え：スタックのトップ2つを入れ替える |
| `%` | 37 | 剰余：スタックから x, y を取り出し y % x を積む |
| `&` | 38 | （TODO / 未実装） |
| `'` | 39 | （TODO / 未実装） |
| `(` | 40 | 比較（小なり）：y < x なら 1、そうでなければ 0 を積む |
| `)` | 41 | 比較（大なり）：y > x なら 1、そうでなければ 0 を積む |
| `*` | 42 | 乗算：スタックから x, y を取り出し y * x を積む |
| `+` | 43 | 加算：スタックから x, y を取り出し y + x を積む |
| `,` | 44 | 除算：スタックから x, y を取り出し y // x を積む |
| `-` | 45 | 減算：スタックから x, y を取り出し y - x を積む |
| `.` | 46 | ジャンプ：スタックから x, y を取り出しポインタを [x, y] へ移動 |
| `/` | 47 | 反射：移動方向を右下・左上の軸で反射させる (dx, dy = -dy, -dx) |
| `0`〜`9` | 48〜57 | 数値：対応する 0〜9 の値をスタックに積む |
| `:` | 58 | 複製：スタックのトップにある値を複製して積む |
| `;` | 59 | 終了：プログラムの実行を停止する |
| `<` | 60 | 移動：方向を「左」に設定する |
| `=` | 61 | 比較（等価）：y == x なら 1、そうでなければ 0 を積む |
| `>` | 62 | 移動：方向を「右」に設定する |
| `?` | 63 | 条件分岐：スタックから x を取り出し、0 なら次の命令をスキップ |
| `@` | 64 | 回転：トップ3つの値を回転させる (x, y, z -> y, z, x) |
| `[` | 91 | （TODO / 未実装） |
| `\` | 92 | 反射：移動方向を右上・左下の軸で反射させる (dx, dy = dy, dx) |
| `]` | 93 | （TODO / 未実装） |
| `^` | 94 | 移動：方向を「上」に設定する |
| `_` | 95 | 水平反射：上下移動中の場合、その方向を反転させる |
| `a`〜`f` | 97〜102 | 数値：10進数の 10〜15 をスタックに積む |
| `g` | 103 | 取得：スタックから x, y を取り出し、座標 [x, y] の値を積む |
| `i` | 105 | 入力：入力バッファから1つ取り出し積む（空なら -1） |
| `l` | 108 | 長さ：現在のスタックのサイズ（要素数）を積む |
| `n` | 110 | 出力：スタックから値を取り出し、output_buffer に追加する |
| `o` | 111 | （TODO / 未実装） |
| `p` | 112 | 配置：スタックから x, y, z を取り出し、座標 [x, y] に z を書き込む |
| `r` | 114 | 反転：スタック全体の順序を逆にする |
| `v` | 118 | 移動：方向を「下」に設定する |
| `x` | 120 | ランダム：移動方向を上下左右からランダムに選ぶ |
| `{` | 123 | 左シフト：スタックを左に回転させる（底の値をトップへ） |
| `\|` | 124 | 垂直反射：左右移動中の場合、その方向を反転させる |
| `}` | 125 | 右シフト：スタックを右に回転させる（トップの値を底へ） |
| `~` | 126 | 破棄：スタックのトップにある値を1つ取り除いて捨てる |

さらにこの問題特有の次のような制約もあります．

- コードに書けるのはaからzだけ．（つまりアルファベットだけで構成する．）


**ゴール**は32回連続で1～10の数が入った1～100の長さの配列のインプットとアウトプットと一致させることです．

## 試したこと

概念的には次のアルゴリズムを再現するように設計しました．
```python
for _ in loop_num:
    x = key.pop(0)
    x_copy = x
    if x_copy > 0:
        cat_key.append(x)
```

これをfish用に書き換えたのが```0 0 i : 0 ) ? n .```です．これがどの用に動くのか```key=[3, 4]```の場合で解説します．


| 命令 | スタック | インプット | アウトプット | 備考 |
|------|---------|---|---|---|
| **1ループ目** | | | ||
| 0 0  | 0 0 | 3 4 | ||
| i | 0 0 3 | 4 | ||
| : | 0 0 3 3 | 4 | ||
| 0 | 0 0 3 3 0 | 4 | ||
| ) | 0 0 3 1 | 4 | |3>0なので1を積む|
| ? | 0 0 3 | 4 | |1なのでスキップしない|
| n | 0 0 | 4 | 3 ||
| . | | 4 | 3 |code[0][0]に移動|
| **2ループ目** |||||
| 0 0  | 0 0 | 4 | 3 ||
| i | 0 0 4 | | 3 ||
| : | 0 0 4 4 |  | 3 ||
| 0 | 0 0 4 4 0 | | 3 ||
| ) | 0 0 4 1 |  | 3 ||
| ? | 0 0 4 | | 3 ||
| n | 0 0 | | 3 4 ||
| . | | | 3 4 ||
| **3ループ目以降** |||||
| 0 0  | 0 0 | | 3 4 ||
| i | 0 0 -1 | | 3 4 ||
| : | 0 0 -1 -1 |  | 3 4 ||
| 0 | 0 0 -1 -1 0 | | 3 4 ||
| ) | 0 0 -1 0 |  | 3 4 |-1<0なので0を積む|
| ? | 0 0 -1 | | 3 4 |0なのでnをスキップ|
| . | 0 | | 3 4 |code[-1][0]に移動(pythonなのでcode[0][0]と同じ)|


==原理的には==これでクリアできるので，後はこれをアルファベットだけで再現します．

実際に僕が試したコードはこちらです．

```
aaagaagioooooonoaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaalcaagpaaaaalfaagpaalbaagpaaaaaaaaaalaaagpaaaaaldaagp
```

一つづつ解説します．
まずこのコードを分かりやすく分けると
```
a aag aag i oooooono
a*39    l   c   aag   p
a*5     l   f   aag   p
a*2     l   b   aag   p
a*10    l   a   aag   p
a*5     l   d   aag   p
```

になります．

使ったテクニックは次のとおりです．

- ```aag```->`0`
- ```l b aag p```->スタックの長さに対応する命令で```code[0][11]```を書き変える．

```o```の部分が任意の命令に書き換えられて```0 0 i : 0 ) ? n .```が再現できます．

これでクリアしたと思いましたが最終関門で阻まれました．assert文です．

```python
            case 46: # .
                assert len(stack) >= 2
                x = stack.pop()
                y = stack.pop()
                assert 0 <= x < len(code) and 0 <= y < len(code[x])
                pointer = [x, y]
```

「原理的には」と申したのはpythonとしては動作しますが，プログラムが負の値を受け付けていなかったのです．ここで脱落...

## 付録
sever.py を実行するとコードの走っている様子や，スタックの様子を可視化できるようになってます．ぜひチャレンジしてください！